package ItemRecipeExtended

// Standard library imports:
import LinkedList
import HashMap
import ClosureEvents
import ClosureTimers
import ErrorHandling

// Extension library imports:
import ObjectIDManager
import LocalObjectIDs
import ItemRecipe
import IdListConstant
import ResourceSpawns
import UnitExtensions
import ClosuresForItems
import Lodash
import StringExtensions
import ColorUtils

public let ingredientStrings = new HashMap<int, string>()
// Herbs
    ..put(ITEM_BLUE_HERB           , "Blue Herb"   .color(COLOR_TURQUOISE))
    ..put(ITEM_ORANGE_HERB         , "Orange Herb" .color(COLOR_ORANGE))
    ..put(ITEM_PURPLE_HERB         , "Purple Herb" .color(COLOR_VIOLET))
    ..put(ITEM_YELLOW_HERB         , "Yellow Herb" .color(COLOR_YELLOW))
    ..put(ITEM_RIVER_ROOT          , "River Root"  .color(COLOR_TEAL))
    ..put(ITEM_RIVER_STEM          , "River Stem"  .color(COLOR_GRAY))
    ..put(ITEM_ATHELAS_SEED        , "Athelas Seed".color(COLOR_GREEN))

// Basic Materials
    ..put(ITEM_STONE               , "Stone"           .color(COLOR_GRAY))
    ..put(ITEM_FLINT               , "Flint"           .color(COLOR_RED))
    ..put(ITEM_TINDER              , "Tinder"          .color(COLOR_GREEN))
    ..put(ITEM_BONE                , "Bone"            .color(GOLD_COLOR))
    ..put(ITEM_STICK               , "Stick"           .color(COLOR_GREEN))
    ..put(ITEM_MANA_CRYSTAL        , "Mana Crystal"    .color(COLOR_LIGHT_BLUE))
    ..put(ITEM_ELK_HIDE            , "Elk Hide"        .color(COLOR_ORANGE))
    ..put(ITEM_JUNGLE_WOLF_HIDE    , "Jungle Wolf Hide".color(COLOR_ORANGE))
    ..put(ITEM_JUNGLE_BEAR_HIDE    , "Jungle Bear Hide".color(COLOR_ORANGE))
    ..put(ITEM_CLAY_BALL           , "Clay Ball"       .color(COLOR_ORANGE))
    ..put(ITEM_MUSHROOM            , "Mushroom"        .color(COLOR_GREEN))
    ..put(ITEM_MAGIC               , "Magic"           .color(COLOR_TURQUOISE))
    ..put(ITEM_ACORN               , "Acorn"           .color(COLOR_PEANUT))
    ..put(ITEM_THISTLES            , "Thisle"          .color(COLOR_GREEN))

// Crafted Materials
    ..put(ITEM_SPIRIT_WIND        , "Spirit of Wind"    .color(COLOR_LAVENDER))
    ..put(ITEM_SPIRIT_WATER       , "Spirit of Water"   .color(COLOR_TURQUOISE))
    ..put(ITEM_SPIRIT_DARKNESS    , "Spirit of Darkness".color(COLOR_VIOLET))
    ..put(ITEM_ANABOLIC_POTION    , "Anabolic Potion"   .color(COLOR_MAROON))
    ..put(ITEM_IRON_INGOT         , "Iron Ingot"        .color(COLOR_RED))
    ..put(ITEM_STEEL_INGOT        , "Steel Ingot"       .color(COLOR_RED))
    ..put(ITEM_SPEAR              , "Spear"             .color(HIGHLIGHT_COLOR))
    ..put(ITEM_POISON             , "Poison"            .color(COLOR_GREEN))
    ..put(ITEM_ULTRA_POISON       , "Ultra Poison"      .color(COLOR_GREEN))
    ..put(ITEM_SHIELD             , "Shield"            .color(COLOR_PEANUT))
    ..put(ITEM_NETS               , "Nets"              .color(COLOR_LIGHT_BLUE))
    ..put(ITEM_ELK_SKIN_GLOVES    , "Elk Skin Gloves"   .color(COLOR_PEANUT))
    ..put(ITEM_ELK_SKIN_COAT      , "Elk Skin Coat"     .color(COLOR_PEANUT))
    ..put(ITEM_ELK_SKIN_BOOTS     , "Elk Skin Boots"    .color(COLOR_PEANUT))
    ..put(ITEM_WOLF_SKIN_GLOVES   , "Wolf Skin Gloves"  .color(COLOR_PEANUT))
    ..put(ITEM_WOLF_SKIN_COAT     , "Wolf Skin Coat"    .color(COLOR_PEANUT))
    ..put(ITEM_WOLF_SKIN_BOOTS    , "Wolf Skin Boots"   .color(COLOR_PEANUT))
    ..put(ITEM_BEAR_SKIN_GLOVES   , "Bear Skin Gloves"  .color(COLOR_PEANUT))
    ..put(ITEM_BEAR_SKIN_COAT     , "Bear Skin Coat"    .color(COLOR_PEANUT))
    ..put(ITEM_BEAR_SKIN_BOOTS    , "Bear Skin Boots"   .color(COLOR_PEANUT))
    ..put(ITEM_BONE_BOOTS         , "Bone Boots"        .color(COLOR_ORANGE))
    ..put(ITEM_BONE_COAT          , "Bone Coat"         .color(COLOR_ORANGE))
    ..put(ITEM_BONE_GLOVES        , "Bone Gloves"       .color(COLOR_ORANGE))
    ..put(ITEM_BONE_SHIELD        , "Bone Shield"       .color(COLOR_ORANGE))
    ..put(ITEM_SMOKE_BOMB         , "Smoke Bomb"        .color(COLOR_VIOLET))
    ..put(ITEM_TENT_KIT           , "Tent Kit"          .color(COLOR_PEANUT))

// Artifact Materials
    ..put(ITEM_HYDRA_SCALE        , "Hydra Scale".color(ARTIFACT_COLOR))



public class ItemRecipeExt extends ItemRecipe
    var pickUpRange = 700.

    construct(int reward, int charges, boolean ordered, boolean permanent, boolean pickupable, int quickMakeAbilId)
        super(reward, charges, ordered, permanent, pickupable)
        if quickMakeAbilId != 0
            EventListener.onCast(quickMakeAbilId) (unit caster) ->
                onQuickMakeCast(caster)

    function onQuickMakeCast(unit caster)
        let pos = caster.getPos()
        let items = new OwnedLinkedList<item>()
        let inventory = caster.getInventory()

        if caster.isTroll()
            pickUpRange = 100
        if caster.getTypeId() == UNIT_CRAFT_MASTER
            pickUpRange = 300

        caster.dropItems()

        // Look for ingredients in pickUpRange radius around the caster
        findIngredient(items, pos)

        // Testing if the recipe can be assembled
        if this.test(caster, items) != null
            for elem in items
                // Remove transmutable item from inventory list
                inventory.remove(elem)
                caster.addItemHandle(elem)
        // This piece of code would display a message upon crafting failure
        // indicating which ingredients are missing
        // however, there is no way to display this message for the triggering player
        // as the buildings are shared, we cannot retrieve the player who casted quickmake
        // else
        //     printMissingIngredient(items, caster.getOwner())

        customAssemble(caster)
        onQuickMakeEnd(caster, inventory)

        destroy items
        destroy inventory

    // In some case, I don't want to rely on ItemRecipe assemble behavior, I don't know if there's
    // a proper way to "avoid" using it
    function customAssemble(unit caster)
        if caster.getTypeId() == UNIT_TANNERY
            this.assemble(caster)


    function findIngredient(OwnedLinkedList<item> items, vec2 pos)
        let iter = this.getIngredients().iterator()

        while iter.hasNext()
            let ingredient = iter.next()
            let found = findNearestItem(pos, pickUpRange, i -> i.getTypeId() == ingredient.itemTypeId)

            if found != null
                while iter.hasNext() and iter.lookahead().index == ingredient.index
                    iter.next()
                items.add(found)
                // We don't want to iterate over same item multiple time
                found.setVisible(false)
        iter.close()
        // Setting the items visible again so they aren't "lost" even if recipe assemble fails
        for elem in items
            elem.setVisible(true)

    function onQuickMakeEnd(unit caster, LinkedList<item> inventory)
        this.requirement.removeUnit(caster.getTypeId())
        this.requirement.addUnit(UNIT_DUMMY)

        for elem in inventory
            caster.addItemHandle(elem)
        caster.moveInventoryDown()

        this.requirement.removeUnit(UNIT_DUMMY)
        this.requirement.addUnit(caster.getTypeId())

    function addRecipeString(int quickMakeAbilId)
        // nullTimer used to let the ItemRecipe instance initialize itself
        nullTimer() ->
            let quickMakeTooltip = getAbilityExtendedTooltip(quickMakeAbilId, 0)
            let newToolTip = quickMakeTooltip + "\n\n"  + getRecipeString(this.getIngredients(), "\n")
            setAbilityExtendedTooltip(quickMakeAbilId, newToolTip, 0)

    function getMissingIngredient(LinkedList<item> items) returns LinkedList<RecipeIngredient>
        let iter = this.getIngredients().iterator()
        var slot = 0
        let missingIngredients = new LinkedList<RecipeIngredient>

        while iter.hasNext()
            var ingredient = iter.next()
            let idx = ingredient.index
            let itm = items.get(slot)

            while ingredient.index == idx
                if itm != null and ingredient.itemTypeId == itm.getTypeId()
                    missingIngredients.removeIf(ingredient -> ingredient.index == idx)
                    break
                else
                    missingIngredients.add(ingredient)
                if not iter.hasNext() or iter.lookahead().index != idx
                    break
                ingredient = iter.next()

            // Seek node which is not part of this batch
            while iter.hasNext()
                if iter.lookahead().index != idx
                    break
                iter.next()
            slot++
        iter.close()
        return missingIngredients

    function printMissingIngredient(LinkedList<item> items, player whichPlayer)
        let missingIngredient = getRecipeString(this.getMissingIngredient(items), " ")
        let msg = "You are missing ".color(GENERAL_COLOR) + missingIngredient + " to craft this item".color(GENERAL_COLOR)
        printTimedToPlayer(msg, 5, whichPlayer)

function getRecipeString(LinkedList<RecipeIngredient> ingredients, string separator) returns string
    var recipeStr = ""
    let iter = ingredients.iterator()

    while iter.hasNext()
        var ingredient = iter.next()
        var ingredientCounter = 1

        while iter.hasNext() and iter.lookahead().itemTypeId == ingredient.itemTypeId
            ingredientCounter++
            ingredient = iter.next()

        if ingredientCounter == 1 and ingredient.charges > 0
            ingredientCounter = ingredient.charges

        recipeStr += "{0}x ".format(ingredientCounter.toString())
        recipeStr += getIngredientName(ingredient)

        while iter.hasNext() and ingredient.index == iter.lookahead().index
            recipeStr += "/"
            ingredient = iter.next()
            recipeStr += getIngredientName(ingredient)

        if iter.hasNext()
            recipeStr += separator
    return recipeStr

function getIngredientName(RecipeIngredient ingredient) returns string
    var toRet = ""
    if not ingredientStrings.has(ingredient.itemTypeId)
        error("Ingredient {0} is not registered for recipe string creation".format(ingredient.itemTypeId.asObjectName()))
        // Maybe do not return anything, otherwise this will report only the first error encountered
        // during this getRecipeString() call
        return toRet
    toRet += ingredientStrings.get(ingredient.itemTypeId)
    if ingredient.perishable == false
        toRet += " (Refunded after crafting)".color(GOLD_COLOR)
    return toRet


init
    registerItemRecipeEvent() ->
        let ingredientUsed = getEventItemRecipeIngredients()
        let itemRecipeUnit = getEventItemRecipeUnit()

        // Filter recipe island demo gatherer unit
        if not itemRecipeUnit.getPos().isInRect(gg_rct_vision)
            for ingredient in ingredientUsed
                if (MATERIAL_COUNTER_LIST.has(ingredient.getTypeId()))
                    lowerItem(1)
