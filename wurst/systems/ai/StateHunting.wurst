package StateHunting

import State
import Computer
import LinkedList
import LocalObjectIDs
import ObjectIds
import OrderIds
import UnitExtensions
import MoveCorpses

constant FIRE_BUILD_DURATION = 7.0
constant SLEEP_DURATION = 6.0

enum subRoutines
    HUNT
    GRABMEAT
    EXPLORE

/**
    Here's a list of bugs to fix :
        -Make bot wait longer near fire to regain Heat
        -When bot goes to cook meat, make him go closer if it needs to regain Heat
        -When hunting and unit has one hit less and its running away, just finish it off instead of bodyblocking
        -The time the bot should start moving for body block when unit is still netted should depend on the unit facing angle
        (when the unit is roughly facing the hunter time should be 0, but if it's facing the other direction time should be ~0.6 (3 ticks))
*/

public class Hunting extends State
    private unit target
    private vec2 targetPos
    private vec2 approxTargPos
    private int targetTS
    private subRoutines sRout
    private bool hasTarget
    private bool isWaitingConstruction
    construct(Computer computer, int firstTick)
        super(computer, firstTick)
        sRout = subRoutines.EXPLORE
        hasTarget = false // Safety net, but all conditions are considered we can possibly remove it
        isWaitingConstruction = false
    override function main()
        switch sRout
            case HUNT
                hunt()
            case GRABMEAT
                grabMeat(targetPos)
            case EXPLORE
                explore()
            default
                sTransition(subRoutines.EXPLORE)

    private function sTransition(subRoutines sRout)
        this.sRout = sRout
        transition(routines.MAIN)

    private function sTransition(subRoutines sRout, real time)
        this.sRout = sRout
        transition(routines.MAIN, troll.getPos(), time)

    override protected function full()
        if troll.hasItemById(ITEM_FIRE_KIT) or builders.has(troll)
            if troll.hasItemById(ITEM_FIRE_KIT)
                build(ITEM_FIRE_KIT, UNIT_FIRE)
                isWaitingConstruction = true
            else if builders.get(troll) == 0
                if troll.getMana() < troll.getMaxMana() * 60 and troll.getHeat() > 20
                    troll.issueTargetOrderById(OrderIds.sleep, troll)
                    builders.remove(troll)
                    transition(routines.IDLE, BUFF_SLEEP, SLEEP_DURATION)
                else
                    // Maybe there's a better routine to do while waiting for fire to build
                    builders.remove(troll)
                    sTransition(subRoutines.EXPLORE, FIRE_BUILD_DURATION)
        else if not getAlliedUnitInRadiusById(troll.getPos(), UNIT_FIRE, 500).isEmpty()
            let fire = getAlliedUnitInRadiusById(troll.getPos(), UNIT_FIRE, 500).peek()
            // HashMap buildings returns if the building has finished constructing or not
            // This should make the bot able to drop meat while it's waiting for the fire to finish building
            if isWaitingConstruction and buildings.has(fire)
                if buildings.get(fire)
                    buildings.remove(fire)
                    isWaitingConstruction = false
                else if counts.get(troll) > 0
                    // Switch depending on weither or not the unit has drop raw ability
                    if not troll.hasAbility(DROP_IDS.get(counts.get(troll)))
                        switchAbilities(troll)
                    else
                        troll.issueImmediateOrderById(OrderIds.replenish)
            if counts.get(troll) > 0
                // Switch depending on weither or not the unit has drop raw ability
                if not troll.hasAbility(DROP_IDS.get(counts.get(troll)))
                    switchAbilities(troll)
                else
                    troll.issueImmediateOrderById(OrderIds.replenish)
            else if isItemInRadius(troll.getPos(), ITEM_COOKED_MEAT, 700)
                pickItem(troll.getPos(), ITEM_COOKED_MEAT, 700)
            else if not getUnitsInRadius(fire.getPos(), UNIT_MEAT, 700).isEmpty()
                fire.issueImmediateOrderById(OrderIds.battlestations)
            else
                sTransition(subRoutines.EXPLORE)
        else
            if not getAlliedUnitInRadiusById(troll.getPos(), UNIT_FIRE, 4000).isEmpty()
                let fires = getAlliedUnitInRadiusById(troll.getPos(), UNIT_FIRE, 4000)
                fires.sortWith((a, b) -> unitDistanceSort(a, b))
                move(fires.pop().getPos())
            // else craft a fire we need to make item memory first, might aswell do unit memory
            // best idea here is to create the base object feature first?


    function explore()
        if not stats()
            if findAnimalTarget()
                sTransition(subRoutines.HUNT)
            else
                exploreArea()
    
    private function hunt()
        if not statsUrgent()
            if hasTarget
                attackTarget()
            else
                sTransition(subRoutines.EXPLORE)

    private function grabMeat(vec2 pos)
        if not statsUrgent()
            if not pickingCorpse(pos) and tick mod 3 == 0
                sTransition(subRoutines.EXPLORE)

    private function findAnimalTarget() returns bool
        let temp = CreateGroup()
        ..enumUnitsInRange(troll.getPos(), 2500)
        for u in temp
            if not IsUnitVisible(u, owner)
                temp.removeUnit(u)
        let sort = temp.asList()
        if not sort.has(target)
            sort.add(target)
        // TODO : better sorting
        sort.sortWith((a, b) -> unitDistanceSort(a, b))
        // sort.sortWith((a, b) -> unitHealthSort(a, b))

        for u in sort
            if(u.getTypeId() == UNIT_ELK)
                this.target = u
                hasTarget = true
                return true
        return false

    private function attackTarget()
        // ** This is tailored to hunter and wont work for other classes, using this to structure the states
        if target.isAlive()
            targetPos = target.getPos()
            if IsUnitVisible(target, owner)
                targetTS = tick
                // TARGET CAN MOVE
                if not target.isImmobilized()
                    if target.getHP() == target.getMaxHP()
                        if computer.isDistanceBT(targetPos, 128)
                            move(target.getPos())
                        else if tick mod 2 == 0 and computer.isDistanceLT(targetPos, 128) and troll.getAbilityCooldownRemaining(ABILITY_HUNTER_WEB) == 0.0
                            troll.issueTargetOrderById(OrderIds.web, target)
                    else 
                        // Tries to net unit with given interval to not cancel the animation
                        if tick mod 2 == 0 and computer.isDistanceLT(targetPos, 700) and troll.getAbilityCooldownRemaining(ABILITY_HUNTER_WEB) == 0.0
                            troll.issueTargetOrderById(OrderIds.web, target)
                        // Net if on cooldown
                        else if troll.getAbilityCooldownRemaining(ABILITY_HUNTER_WEB) > 0.0
                            // Should return true when the unit is not moving
                            if GetUnitCurrentOrder(target) == "none".fromRawCode()
                                move(target.getPos())
                            // Else if the unit is moving try to go infront of it
                            else if target.getTypeId() == UNIT_ELK and computer.isDistanceLT(targetPos, 300)
                                move(target.getPos() + target.getFacingAngle().direction(200))
                            // Elk ran to africa and is still running
                            else 
                                move(target.getPos())
                        // unit is moving and net is off cooldown (not close enough to net I guess)
                        else if computer.isDistanceBT(targetPos, 700)
                            move(target.getPos())
                        // this might be uneeded and cause problem?
                        else if tick mod 2 == 0 
                            attack(target)
                // TARGET IS IMMOBILIZED
                else
                    // TODO : marsun suggested canceling attack animation
                    if not troll.hasAbility(ABILITY_TRACK) or troll.getAbilityCooldownRemaining(ABILITY_TRACK) > 0 or target.getAbilityLevel(BUFF_TRACKED) > 1
                        if target.getHP() > target.getMaxHP() * .33 and troll.getAbilityCooldownRemaining(ABILITY_HUNTER_WEB) <= 2.8 and target.getTypeId() == UNIT_ELK
                            move(target.getPos() + target.getFacingAngle().direction(200))
                        else if computer.isDistanceBT(targetPos, 128) // maybe change this to max attack range rather than 128
                            move(target.getPos())
                        else if tick mod 2 == 0
                            attack(target)
                    else if tick mod 2 == 0
                        troll.issueTargetOrderById(OrderIds.faeriefire, target)
            else if (tick - targetTS) < 20
                // Totally hacking because it knows the position will see
                // what i can do to improve that
                approxTargPos = targetPos
                if tick mod 2 == 0 and computer.isDistanceBT(targetPos, 128)
                    move(targetPos)
            else if computer.isDistanceBT(approxTargPos, 200)
                move(approxTargPos)
            else
                hasTarget = false
                sTransition(subRoutines.EXPLORE)
        else
            hasTarget = false
            sTransition(subRoutines.GRABMEAT)
            