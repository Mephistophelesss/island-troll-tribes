package Geometry
import LinkedList
import ErrorHandling
import TerrainUtils
import LocalObjectIDs
import BuildingDummy

public class Point
    private unit uTarget
    private vec2 target
    private bool isWalkable
    construct(vec2 target)
        this.target = target

    construct(vec2 target, bool checkWalkable)
        if target.isTerrainWalkable() and checkWalkable
            this.target = target
            this.isWalkable = true
        else
            this.target = target
            this.isWalkable = false

    construct(unit target)
        this.uTarget = target
        this.target = target.getPos()

    function update()
        if not uTarget == null
            this.target = uTarget.getPos()

    function update(vec2 target)
        this.target = target

    function getTarget() returns vec2
        return this.target

    function isWalkable() returns bool
        return isWalkable

    function isBuildable() returns bool
        var isBuildable = false
        if not uTarget == null
            DUMMY_BUILDER.setOwner(uTarget.getOwner(), false)
            isBuildable = IssueBuildOrderById(DUMMY_BUILDER, UNIT_DUMMY_BUILDING, this.getTarget().x, this.getTarget().y)
            DUMMY_BUILDER.setOwner(players[PLAYER_NEUTRAL_PASSIVE], false)
        else
            isBuildable = IssueBuildOrderById(DUMMY_BUILDER, UNIT_DUMMY_BUILDING, this.getTarget().x, this.getTarget().y)
        return isBuildable

    function sortClosestToTarget(Point a, Point b) returns int
        return (target.toTileCenter().distanceToSq(a.getTarget()) - target.toTileCenter().distanceToSq(b.getTarget())).round()

    function getNearestBuildable() returns vec2
        let latticePoints = new LinkedList<Point>
        let buildPoints = new LinkedList<Point>
        for int i = 0 to 100
            for int j = 0 to 2*(i)+1 // y axis
                for int k = 0 to 2*(i)+1 // x axis
                    let center = ((2*i+1)/2).ceil()
                    var x = 0.
                    var y = 0.
                    if j < center
                        y = -64.*(center - j)
                    else if j > center
                        y = 64.*(j - center)
                    else
                        y = 0
                    if k < center
                        x = -64.*(center - k)
                    else if k > center
                        x = 64.*(k - center)
                    else
                        x = 0
                    latticePoints.add(new Point(target.toTileCenter() + vec2(x,y)))
            for point in latticePoints
                if point.isBuildable()
                    buildPoints.add(point)
            if not buildPoints.isEmpty()
                buildPoints.sortWith((Point a, Point b) -> sortClosestToTarget(a, b))
                return buildPoints.getFirst().getTarget()
            latticePoints.clear()
        return this.getTarget()

    function close() returns thistype
        destroy this
        return null

public class Set
    private LinkedList<rect> subSets
    private LinkedList<rect> invalidSet
    private region familySet

    construct()
        subSets = new LinkedList<rect>()
        invalidSet = new LinkedList<rect>()
        familySet = CreateRegion()

    function union(rect r)
        subSets.add(r)
        familySet.addRect(r)
    
    function minus(rect r)
        // There surely is a better way to do this but im way too tired rn
        // We need to take all the corner points and the center one
        var hasPoint = false
        if r.getRightBot().isInRegion(familySet)
            hasPoint = true
        else if r.getRightTop().isInRegion(familySet)
            hasPoint = true
        else if r.getLeftBot().isInRegion(familySet)
            hasPoint = true
        else if r.getLeftTop().isInRegion(familySet)
            hasPoint = true
        else if r.getCenter().isInRegion(familySet)
            hasPoint = true
        if hasPoint == true
            invalidSet.add(r)    

    function has(vec2 point) returns bool
        var isValid = true
        for elements in invalidSet
            if elements.contains(point)
                isValid = false
                break
        return point.isInRegion(familySet) and isValid

    function getRandomElement(bool isWalkable) returns vec2
        if not subSets.isEmpty()
            let points = new LinkedList<Point>()
            while points.isEmpty()
                for elements in subSets
                    let point = new Point(elements.randomPoint(), isWalkable)
                    if isWalkable
                        if point.isWalkable() and this.has(point.getTarget())
                            points.add(point)
                    else if this.has(point.getTarget())
                        points.add(point)
                    else
                        point.close()
            points.shuffle()
            return points.peek().getTarget()
        else
            error("ERROR: Trying to get random point from empty Set object defined in Geometry package!")
            return vec2(0,0)

    function getRect() returns rect
        // Let's initialize the point in the center of one of the subset rect
        vec2 array[4] points = [subSets.peek().getCenter(), subSets.peek().getCenter(), subSets.peek().getCenter(), subSets.peek().getCenter()]
        for elements in subSets
            // Top left
            if elements.getLeftTop().x < points[0].x and elements.getLeftTop().y > points[0].y
                points[0] = elements.getLeftTop()
            // Top right
            if elements.getRightTop().x > points[1].x and elements.getRightTop().y > points[1].y
                points[1] = elements.getRightTop()
            // Bot left
            if elements.getLeftBot().x < points[2].x and elements.getLeftBot().y < points[2].y
                points[2] = elements.getLeftBot()
            // Bot right
            if elements.getRightBot().x > points[3].x and elements.getRightBot().y < points[3].y
                points[3] = elements.getRightBot()
        return Rect(points[0].x < points[2].x ? points[0].x : points[2].x,
                    points[2].y < points[3].y ? points[2].y : points[3].y,
                    points[1].x > points[3].x ? points[1].x : points[3].x,
                    points[0].y > points[1].y ? points[0].y : points[1].y)

    function close() returns thistype
        destroy this
        return null

    ondestroy
        subSets.clear()
        invalidSet.clear()
        familySet.destr()


