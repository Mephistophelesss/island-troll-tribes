package State

import Computer
import OrderIds
import Geometry
import MoveCorpses
import LocalObjectIDs
import SoundUtils
import GameConfig
import TerrainUtils
import UnitExtensions
import Tribe
import LinkedList
import RegisterEvents
import ClosuresForItems
import ClosureForGroups
import PlayerExtensions
import Troll
import UnitEntity
import HashMap

class ItemContext
    bool hasItem
    construct()
        this.hasItem = false

    function close()
        destroy this

public enum subStates
    MAIN
    STUCK
    FULL
    IDLE

public abstract class State

    // Protected Members:
    protected Computer computer
    protected subStates symbol
    protected subStates prevSymbol
    protected int firstTick
    protected int tick
    protected vec2 temp
    protected vec2 buildingPoint
    protected unit troll
    protected player owner

    // Private Members:
    private bool returnPrev
    private int _typeId
    private Point curPoint
    private int transTime
    private Point waypoint

    // Static Members:
    static HashMap<unit,int> builders = new HashMap<unit,int>()

    construct(Computer computer, int firstTick)
        this.computer = computer
        this.firstTick = firstTick
        this.tick = 0
        this.troll = computer.getTroll()
        this.owner = computer.getPlayer()
        this.returnPrev = false
        this.symbol = subStates.MAIN
        this.curPoint = new Point(troll)

    function update(int tick)
        this.tick = tick
        panic()
        switch symbol
            case MAIN
                print("main")
                if transTime == 0
                    main()
                else
                    timedMain()
            case FULL
                print("full")
                full()
            case IDLE
                print("idle")
                idle()
            default
                transition(subStates.MAIN)
        
    function changeState(States nextState)
        computer.transition(nextState)

    /**
        Protected transition functions:
            execute transition between sub states enumerated in update
    */
    protected function transition(subStates symbol)
        this.symbol = symbol

    protected function transition(subStates symbol, int buffId)
        this.returnPrev = true
        this.prevSymbol = this.symbol
        this._typeId = buffId
        transition(symbol)

    protected function transition(subStates symbol, real time)
        this.returnPrev = true
        this.prevSymbol = this.symbol
        this.transTime = (tick + (time/.2)).ceil()
        transition(symbol)
        
    protected function transition(subStates symbol, vec2 loc, real time)
        this.temp = loc
        transition(symbol, time)

    protected function transition(subStates symbol, int buffId, real time)
        this.transTime = (tick + (time/.2)).ceil()
        transition(symbol, buffId)

    /**
        abstract main function:
            where the main loop is executed in the extended states
    */
    abstract function main()

    protected function timedMain()
        if this.tick >= transTime
            if computer.isDistanceBT(temp, 300)
                move(temp)
            else
                symbol = prevSymbol
        else
            main()
    
    protected function full() // doesn't have to be abstract because some state dont have full.

    protected function build(int itemId,int buildingId)
        print(builders.has(troll))
        if not builders.has(troll)
            curPoint.update()
            builders.put(troll, buildingId)
            troll.useItemPoint(troll.getItemById(itemId), curPoint.getNearestBuildable())
        else if builders.has(troll)
            if tick mod 10 == 0
                curPoint.update()
                troll.useItemPoint(troll.getItemById(itemId), curPoint.getNearestBuildable())

    protected function Eat()

    protected function stats()
        if troll.getMana() <= troll.getMaxMana() * 0.20 and troll.getHeat() > 35
            troll.issueTargetOrderById(OrderIds.sleep, troll)
            transition(subStates.IDLE, BUFF_SLEEP, 6.)
        else if troll.getHeat() <= 35
            skip
            // find fire 
    protected function statsUrgent()
        if troll.getMana() <= troll.getMaxMana() * 0.10 and troll.getHeat() > 30
            troll.issueTargetOrderById(OrderIds.sleep, troll)
            transition(subStates.IDLE, BUFF_SLEEP, 6.)

    private function idle()
        print("idle")
        if tick == transTime or troll.getAbilityLevel(_typeId) > 0
            transTime = 0
            _typeId = 0
            if returnPrev
                print("return prev")
                returnPrev = false
                transition(prevSymbol)
            else
                transition(subStates.MAIN)
        
    protected function panic()
        if troll.getMana() > troll.getMaxMana() * 0.20 and troll.getAbilityCooldownRemaining(OrderIds.berserk) == 0
            troll.issueImmediateOrderById(OrderIds.berserk)          

    protected function move(vec2 target)
        troll.issuePointOrderById(Orders.moveAI, target)

    protected function attack(unit target)
        troll.issueTargetOrderById(Orders.attack, target)

    protected function unitDistanceSort(unit a, unit b) returns int
        return (troll.getPos().distanceToSq(a.getPos()) - troll.getPos().distanceToSq(b.getPos())).round()

    protected function unitHealthSort(unit a, unit b) returns int
        return (a.getHP() - b.getHP()).round()

    protected function getAlliedUnitInRadiusById(vec2 target, int unitId, real radius) returns LinkedList<unit>
        let unitList = getUnitsInRadius(target, unitId, radius)
        for u in unitList
            if not u.isAllyOf(owner)
                unitList.remove(u)
        return unitList
    
    protected function hasItemInRadius(int itemId, real radius) returns bool
        let searchRect = Rect(0., 0., radius, radius)
        let ctx = new ItemContext() // TODO : check if you need to use context for the item closure
        forItemsInRect(searchRect) (item i) ->
            if i.getTypeId() == itemId
                ctx.hasItem = true
        if ctx.hasItem
            ctx.close()
            return true
        return false

    protected function pickItem(int itemId, real radius)
        let searchRect = Rect(0., 0., radius, radius)
        forItemsInRect(searchRect) (item i) ->
            if i.getTypeId() == itemId
                troll.issueTargetOrderById(OrderIds.smart, i)   

    protected function getUnitsInRadius(vec2 target, int unitId, real radius) returns LinkedList<unit>
        let unitList = new LinkedList<unit>
        forUnitsInRange(target, radius) (unit u) ->
            if u.getTypeId() == unitId
                unitList.add(u)
        return unitList

    protected function pickingCorpse(vec2 target) returns bool
        var hasCorpse = true
        let corpses = getUnitsInRadius(target, UNIT_MEAT, 300)
        let point = new Point(corpses.peek().getPos())
        // Check if we have corpses with a radius of 300 around the target vec2
        if not corpses.isEmpty()
            // Move if we are far from the target
            if computer.isDistanceBT(target, 128)
                move(target)
            // Check if the amount of carrying corpse + the corpse on the ground are higher than 8 and our troll has a fire with a nearby spot to build it
            else if counts.get(troll) + corpses.size() > 8 and troll.hasItemById(ITEM_FIRE_KIT) and point.getTarget().distanceTo(point.getNearestBuildable()) < 500
                hasCorpse = false
                transition(subStates.FULL)
            // Check if we have less than 8 carrying corpses with an interval of 2 ticks
            else if counts.get(troll) < 8 and tick mod 2 == 0
                // If we ares lose enough to the corpse (could increase the distance a little bit) we fake picking up meat
                if computer.isDistanceLT(corpses.peek().getPos(), 128)
                    // Apparently might cause desync
                    //CORPSE_LOAD_SOUND.playOnPoint(troll.getPos3Real())
                    troll.setAnimation("Spell")
                    updateCount(troll, 1)
                    corpses.pop().remove()
                // If we are not close enough check if the vec2 is pathable and try to move toward it
                else if computer.isDistanceBT(corpses.peek().getPos(), 128) and corpses.peek().getPos().isTerrainWalkable()
                    move(corpses.peek().getPos())
                else
                    hasCorpse = false 
            // Check if we are full if so we transition to full substate
            else if counts.get(troll) >= 8
                hasCorpse = false
                transition(subStates.FULL)
            // if the target is not pathable then return to main substate
            else if not target.isTerrainWalkable()
                hasCorpse = false
                transition(subStates.MAIN)
        else
            hasCorpse = false
        return hasCorpse

    protected function exploreArea()
        // TODO: MT suggested using bool instead of null ref for condition
        if waypoint == null
            waypoint = new Point(computer.getCurrentArea().getRandomWalkablePoint())
        else if computer.isDistanceLT(waypoint.getTarget(), 100)
            waypoint = waypoint.close()
        else if tick mod 2 == 0
            move(waypoint.getTarget())

    function close() returns thistype
        destroy this
        return null

init
    registerPlayerUnitEvent(EVENT_PLAYER_UNIT_CONSTRUCT_START) ->
        // Simplest way to track back, with building transfering owner
        if gameConfig.isTribeOwnsBuildingsEnabled()
            forUnitsInRange(GetTriggerUnit().getPos(), 500) (unit u) ->
                let entity = UnitEntity.findForUnit(u)
                if entity instanceof Troll
                    if State.builders.has(u)
                        State.builders.remove(u)
                        State.builders.put(u, 0)
        else if State.builders.get(GetTriggerPlayer().getTroll()) == GetTriggerUnit().getTypeId()
            State.builders.put(GetTriggerPlayer().getTroll(), 0)
