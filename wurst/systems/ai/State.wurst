package State

import Computer
import OrderIds
import Geometry
import MoveCorpses
import LocalObjectIDs
import SoundUtils
import GameConfig
import TerrainUtils
import UnitExtensions
import LinkedList
import RegisterEvents
import ClosuresForItems
import ClosureForGroups
import PlayerExtensions
import Troll
import UnitEntity
import HashMap

class ItemContext
    bool hasItem
    construct()
        this.hasItem = false

    function close()
        destroy this

public enum routines
    MAIN
    STUCK
    FULL
    IDLE
/**
    TODO :
        -Finish the basic routine that execute the maintenance (eat, stats, etc.)
    
    Structures to make :
        -Class to have "base" object, also memory for items and possible hunting targets***
        -Something with target vectors to localize if theres any structures or fake trees blocking the way (we can use hacks here to help 
        with the lack of conciousness)**
        -Analyse the surroundings of the troll*
            i.e. : elk is facing the hunter and the hunter position is neighbor to 2 unpathable object (basically the hunter is blocking the elk)
            then the hunter shouldn't try to body block
        -Some kind of algorithm to do get more efficient waypoints for exploration (take into accounts unit killed/items gathered) to know
        when to move to a new island. (should be done in the area package)**

*/
public abstract class State

    // Protected Members:
    protected Computer computer
    protected routines rout
    protected routines prevRout
    protected int firstTick
    protected int tick
    protected vec2 temp
    protected vec2 buildingPoint
    protected unit troll
    protected player owner

    // Private Members:
    private bool returnPrev
    private int _typeId
    private Point curPoint
    private int transTime
    private Point waypoint

    // Static Members:
    static HashMap<unit,int> builders = new HashMap<unit,int>()
    static HashMap<unit,bool> buildings = new HashMap<unit,bool>()

    construct(Computer computer, int firstTick)
        this.computer = computer
        this.firstTick = firstTick
        this.tick = 0
        this.troll = computer.getTroll()
        this.owner = computer.getPlayer()
        this.returnPrev = false
        this.rout = routines.MAIN
        this.curPoint = new Point(troll)

    function update(int tick)
        this.tick = tick
        panic()
        switch rout
            case MAIN
                print("main")
                if transTime == 0
                    main()
                else
                    timedMain()
            case FULL
                print("full")
                full()
            case IDLE
                print("idle")
                idle()
            default
                transition(routines.MAIN)
        
    function changeState(States nextState)
        computer.transition(nextState)

    /**
        Protected transition functions:
            execute transition between sub states enumerated in update
    */
    protected function transition(routines rout)
        this.rout = rout

    protected function transition(routines rout, int buffId)
        this.returnPrev = true
        this.prevRout = this.rout
        this._typeId = buffId
        transition(rout)

    protected function transition(routines rout, real time)
        this.returnPrev = true
        this.prevRout = this.rout
        this.transTime = (tick + (time/.2)).ceil()
        transition(rout)
        
    protected function transition(routines rout, vec2 loc, real time)
        this.temp = loc
        transition(rout, time)

    protected function transition(routines rout, int buffId, real time)
        this.transTime = (tick + (time/.2)).ceil()
        transition(rout, buffId)

    /**
        abstract main function:
            where the main loop is executed in the extended states
    */
    abstract function main()

    protected function timedMain()
        if this.tick >= transTime
            if computer.isDistanceBT(temp, 300)
                move(temp)
            else
                rout = prevRout
        else
            main()
    
    protected function full() // doesn't have to be abstract because some state dont have full.

    protected function build(int itemId,int buildingId)
        print(builders.has(troll))
        if not builders.has(troll)
            curPoint.update()
            builders.put(troll, buildingId)
            troll.useItemPoint(troll.getItemById(itemId), curPoint.getNearestBuildable())
        else if builders.has(troll)
            if tick mod 10 == 0
                curPoint.update()
                troll.useItemPoint(troll.getItemById(itemId), curPoint.getNearestBuildable())

    protected function Eat()

    protected function stats() returns bool
        if troll.getMana() <= troll.getMaxMana() * 0.20 and troll.getHeat() > 35
            troll.issueTargetOrderById(OrderIds.sleep, troll)
            transition(routines.IDLE, BUFF_SLEEP, 6.)
            return true
        else if troll.getHeat() <= 35
            skip
            // find fire 
        return false
    protected function statsUrgent() returns bool
        if troll.getMana() <= troll.getMaxMana() * 0.10 and troll.getHeat() > 30
            troll.issueTargetOrderById(OrderIds.sleep, troll)
            transition(routines.IDLE, BUFF_SLEEP, 6.)
            return true
        return false

    private function idle()
        print("idle")
        if tick == transTime or troll.getAbilityLevel(_typeId) > 0
            transTime = 0
            _typeId = 0
            if returnPrev
                print("return prev")
                returnPrev = false
                transition(prevRout)
            else
                transition(routines.MAIN)
        
    protected function panic()
        if troll.getMana() > troll.getMaxMana() * 0.20 and troll.getAbilityCooldownRemaining(OrderIds.berserk) == 0
            troll.issueImmediateOrderById(OrderIds.berserk)          

    protected function move(vec2 target)
        troll.issuePointOrderById(Orders.moveAI, target)

    protected function attack(unit target)
        troll.issueTargetOrderById(Orders.attack, target)

    protected function unitDistanceSort(unit a, unit b) returns int
        return (troll.getPos().distanceTo(a.getPos()) - troll.getPos().distanceTo(b.getPos())).round()

    protected function itemDistanceSort(item a, item b) returns int
        return (troll.getPos().distanceTo(a.getPos()) - troll.getPos().distanceTo(b.getPos())).round()

    protected function unitHealthSort(unit a, unit b) returns int
        return (a.getHP() - b.getHP()).round()

    protected function getAlliedUnitInRadiusById(vec2 target, int unitId, real radius) returns LinkedList<unit>
        let unitList = getUnitsInRadius(target, unitId, radius)
        for u in unitList
            if not u.isAllyOf(owner)
                unitList.remove(u)
        return unitList
    
    protected function isItemInRadius(vec2 target, int itemId, real radius) returns bool
        let searchRect = Rect(0., 0., radius, radius)
        let ctx = new ItemContext() // TODO : maybe you dont have to use context
        searchRect.moveTo(target)
        forItemsInRect(searchRect) (item i) ->
            if i.getTypeId() == itemId
                ctx.hasItem = true
        if ctx.hasItem
            ctx.close()
            return true
        ctx.close()
        return false

    protected function pickItem(vec2 target, int itemId, real radius)
        let searchRect = Rect(0., 0., radius, radius)
        let itemList = new LinkedList<item>()
        searchRect.moveTo(target)
        forItemsInRect(searchRect) (item i) ->
            if i.getTypeId() == itemId
                itemList.add(i)
        itemList.sortWith((a, b) -> itemDistanceSort(a, b))
        // not sure how fast it can pick item
        for i in itemList
            troll.issueTargetOrderById(OrderIds.smart, i) 

    protected function getUnitsInRadius(vec2 target, int unitId, real radius) returns LinkedList<unit>
        let unitList = new LinkedList<unit>
        forUnitsInRange(target, radius) (unit u) ->
            if u.getTypeId() == unitId
                unitList.add(u)
        return unitList

    protected function pickingCorpse(vec2 target) returns bool
        var hasCorpse = true
        let corpses = getUnitsInRadius(target, UNIT_MEAT, 300)
        let point = new Point(corpses.peek().getPos())
        // Check if we have corpses with a radius of 300 around the target vec2
        if not corpses.isEmpty()
            // Move if we are far from the target
            if computer.isDistanceBT(target, 128)
                move(target)
            // Check if the amount of carrying corpse + the corpse on the ground are higher than 8 and our troll has a fire with a nearby spot to build it
            else if counts.get(troll) + corpses.size() > 8 and troll.hasItemById(ITEM_FIRE_KIT) and point.getTarget().distanceTo(point.getNearestBuildable()) < 500
                hasCorpse = false
                transition(routines.FULL)
            // Check if we have less than 8 carrying corpses with an interval of 2 ticks
            else if counts.get(troll) < 8 and tick mod 2 == 0
                // If we ares lose enough to the corpse (could increase the distance a little bit) we fake picking up meat
                if computer.isDistanceLT(corpses.peek().getPos(), 128)
                    // Apparently might cause desync
                    //CORPSE_LOAD_SOUND.playOnPoint(troll.getPos3Real())
                    troll.setAnimation("Spell")
                    updateCount(troll, 1)
                    corpses.pop().remove()
                // If we are not close enough check if the vec2 is pathable and try to move toward it
                else if computer.isDistanceBT(corpses.peek().getPos(), 128) and corpses.peek().getPos().isTerrainWalkable()
                    move(corpses.peek().getPos())
                else
                    hasCorpse = false 
            // Check if we are full if so we transition to full routine
            else if counts.get(troll) >= 8
                hasCorpse = false
                transition(routines.FULL)
            // if the target is not pathable then return to main routine
            else if not target.isTerrainWalkable()
                hasCorpse = false
                transition(routines.MAIN)
        else
            hasCorpse = false
        return hasCorpse

    protected function exploreArea()
        // TODO: MT suggested using bool instead of null ref for condition
        if waypoint == null
            waypoint = new Point(computer.getCurrentArea().getRandomWalkablePoint())
        else if computer.isDistanceLT(waypoint.getTarget(), 100)
            waypoint = waypoint.close()
        else if tick mod 2 == 0
            move(waypoint.getTarget())

    function close() returns thistype
        destroy this
        return null

init
    registerPlayerUnitEvent(EVENT_PLAYER_UNIT_CONSTRUCT_START) ->
        // Simplest way to track back, with building transfering owner
        if gameConfig.isAIEnabled()
            if gameConfig.isTribeOwnsBuildingsEnabled()
                forUnitsInRange(GetTriggerUnit().getPos(), 500) (unit u) ->
                    let entity = UnitEntity.findForUnit(u)
                    if entity instanceof Troll
                        if State.builders.has(u)
                            State.buildings.put(GetTriggerUnit(), false)
                            State.builders.put(u, 0)
            else if State.builders.get(GetTriggerPlayer().getTroll()) == GetTriggerUnit().getTypeId()
                State.buildings.put(GetTriggerUnit(), false)
                State.builders.put(GetTriggerPlayer().getTroll(), 0)
    registerPlayerUnitEvent(EVENT_PLAYER_UNIT_CONSTRUCT_FINISH) ->
        if gameConfig.isAIEnabled()
            if State.buildings.has(GetTriggerUnit())
                State.buildings.put(GetTriggerUnit(), true)