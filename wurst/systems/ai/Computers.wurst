package Computers

// Standard library imports:
import ClosureForGroups
import ClosureTimers
import HashMap
import LinkedList
import RegisterEvents

// Third-party imports:
import LodashExtensions

// Local imports:
import ClassSelector
import Computer
import Game
import GameConfig
import LocalObjectIDs
import PlayerExtensions
import Tribe
import UnitExtensions

LinkedList<Computers> computersList = null
LinkedList<Draft> draftList = null

// TODO : Only spawn troll when eai is active (this is done in Tribe package), and investigate possibility of some weird interaction with win condition and bots

/**
    Draft classes for the computer during selection time. Drafting is divised in 2 phases :
        Candidate drafting phase:
            It will choose a candidate class from the selection pool and the preference, and it will warn the player what class
            it intends to pick. If the player select a class that the computer was intending to pick then it will redraft its
            candidate class.
        Drafting phase:
            When one second is left in selection time the computer will pick the class it has for candidate and update its IterableMap
            accordingly. The goal of drafting is to have a map "draft" with the computer playerId for key and the troll unit for value. 
*/
class Draft
    private IterableMap<player, unit> draft
    private IterableMap<player, int> candidate
    private LinkedList<int> preference
    private LinkedList<int> pool
    private Tribe tribe
    private unit totem
    private bool isDraft

    /**
        Draft object are made for every tribe. when the object is constructed it checks to see if the tribe has any member that is
        controlled by a computer player. If it has one then the object is valid and it initialize the drafting. If it does not have
        any computer player then it destroys itself.
        @param Tribe
            Tribe object that handles team related manipulations
    */
    construct(Tribe tribe)
        draft = new IterableMap<player, unit>()
        candidate = new IterableMap<player, int>()
        preference = new LinkedList<int>()
        pool = new LinkedList<int>()
        this.tribe = tribe
        isDraft = false
        forUnitsInRect(tribe.getSpawn()) u ->
            if u.getTypeId() == UNIT_TROLL_TOTEM
                this.totem = u

        // Prefered class is at the top of the stack
        preference
        // Caster class will prioritized last
        ..add(UNIT_PRIEST)
        ..add(UNIT_MAGE)
        // Gathering class comes second
        ..add(UNIT_THIEF)
        ..add(UNIT_SCOUT)
        ..add(UNIT_GATHERER)
        // Hunting class comes first
        ..add(UNIT_BEAST_MASTER)
        ..add(UNIT_HUNTER)

        for member in tribe.getMembers()
            if member.getController() == MAP_CONTROL_COMPUTER
                draft.put(member, null)

        if draft.size() == 0
            destroy this
        else
            updateCandidate()
    
    /**
        drafting can be called when a unit is sold. Depending on the phase, it either updates the candidate map or it updates
        the draft map.
    */
    function drafting()
        if GetSellingUnit() == totem
            if isDraft
                if candidate.has(GetSoldUnit().getOwner())
                    if GetSoldUnit().getTypeId() == candidate.get(GetSoldUnit().getOwner())
                        draft.put(GetSoldUnit().getOwner(), GetSoldUnit())
            else
                updateCandidate()

    /**
        updateCandidate will update the selection pool and then compare the current candidate draft with the selection pool to
        see if the candidate classes are still available. It only redraft if the candidate class it removed from the pool, if sortWith() (T o1, T o2) ->
        then it warns the player what new class it intends to pick.
    */
    function updateCandidate()
        // TODO: maybe there's a better way to get the selection pool
        if selectorPools.has(tribe)
            // How do you set destroyOnClose() to false so I dont have to make copies here
            pool = selectorPools.get(tribe).getClassAvailable().copy().intersection(preference.copy())
        for key in draft
            if not candidate.get(key) == pool.peek()
                candidate.put(key, pool.pop())
                // TODO: create a new function to get class name from its unitid instead of getting it by creating a new unit
                let temp = createUnit(key, candidate.get(key), tribe.getSpawn().getCenter(), angle(0))
                for member in key.getTribe().getMembers()
                    printTimedToPlayer(key.getColor().toColor().toColorString() + key.getName() + " (BOT)|r: " + " I will pick " + temp.getName() , 10, member)
                temp.remove()
    /**
        pick is called to begin the second phase of drafting, it will order each bot to buy their candidate hero.
    */
    function pick()
        isDraft = true
        for key in draft
            IssueNeutralImmediateOrderById(key, totem, candidate.get(key))

    /**
        random is a static method used to handle cases where the selection time is so small that it is impossible to pick a class.
        @param Tribe
            Tribe object that handles team related manipulations
        @return IterableMap of the computers playerId and their troll unit.
    */
    static function random(Tribe tribe) returns IterableMap<player, unit>
        let draft = new IterableMap<player, unit>
        for member in tribe.getMembers()
            if member.getController() == MAP_CONTROL_COMPUTER
                draft.put(member, null)
        forUnitsInRect(tribe.getSpawn()) u ->
            if draft.has(u.getOwner())
                draft.put(u.getOwner(), u)
        return draft

    /**
        getDraft accessor for the IterableMap draft.
        @return IterableMap of the computers playerId and their troll unit.
    */
    function getDraft() returns IterableMap<player,unit>
        return draft
    /**
        getTribe accessor for the object Tribe.
        @return Tribe of the drafting.
    */
    function getTribe() returns Tribe
        return tribe

    ondestroy
        destroy draft
        destroy pool
        destroy preference

/**
    Computers objects will handles any team related manipulation of the computers. Anything that needs the synchronicity of the 
    computers will be handled by methods (or possibly team states). i.e. Meta-gaming for crafting, attacks on enemy base, 
    defense of ally base, boss killing, etc.
*/
class Computers
    private LinkedList<Computer> computers = null
    private Tribe tribe

    /**
        Computers object are made from draft map made from valid Draft objects or from the static method random. If the draft is empty
        then the object is invalid and it destroy itself (only way to get an empty draft is if the static method random was used),
        otherwise the object is valid and the tribe has at least one computer.
    */
    construct(IterableMap<player, unit> draft, Tribe tribe)
        computers = new LinkedList<Computer>()
        this.tribe = tribe
        for p in draft
            computers.add(new Computer(p, draft.get(p), tribe))
        if computers.size() == 0
            destroy this

    /**
        getTribe accessor for the object Tribe.
        @return Tribe of the computers.
    */
    function getTribe() returns Tribe
        return tribe

    /**
        remove is a method to remove a specific computer from the group of computers
        @param Computer
            Computer object that handles the control of the computer
    */
    function remove(Computer computer)
        computers.remove(computer)

        if computers.size() == 0
            destroy this

    ondestroy
        destroy computers

init
    // Beginning of the grace period
    registerGameStartEvent() ->
        if gameConfig.isAIEnabled()
            computersList = new LinkedList<Computers>()
            if gameConfig.getSelectionTimeAllowed() <= 2
                for tribe in Tribe.getTribes()
                    computersList.push(new Computers(Draft.random(tribe), tribe))
            else
                for draft in draftList
                    computersList.push(new Computers(draft.getDraft(), draft.getTribe()))
                    destroy draft
            destroy draftList
    // Beginning of the selection time
    registerTribeInitializationFinishEvent() ->
        if gameConfig.isAIEnabled()
            draftList = new LinkedList<Draft>()
            if (gameConfig.getSelectionTimeAllowed() > 2)
                for tribe in Tribe.getTribes()
                    draftList.push(new Draft(tribe))
                doAfter(gameConfig.getSelectionTimeAllowed() - 1.0) ->
                    for draft in draftList
                        draft.pick() 

    registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SELL) ->
        if gameConfig.isAIEnabled()
            for draft in draftList
                draft.drafting()

    registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH) ->
        if gameConfig.isAIEnabled()
            if GetDyingUnit().isTroll()
                for computers in computersList
                    if computers.getTribe().isDefeated()
                        computersList.remove(computers)
                if computersList.size() == 0
                    destroy computersList
                    
